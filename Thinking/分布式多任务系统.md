# 设计一个分布式任务系统
## 1. 需要考虑的事项

a. 需要多个机器，能够横向扩展

b. 机器启动后，能够检测到机器活动，同时机器能够将自己的服务注册到管理器上。

c. 执行任务，能够保证冥等性；或者只执行没有执行的任务

d. 各个节点提供的功能必须是无状态的

~~e. 任务如果放在数据库中存储，那么问题，任务如何启动？轮循或者主来调用？~~

    ~~1) 如果用主来调用，那么就需要选主。选主后，由主来进行任务调度。~~
    ~~2) 如果不用选组来调用，那么可以用paxos去获取下一个任务。~~

e. 放在分布式队列中，各个节点订阅队列消息

## 2. 架构

a. 使用Deployment创建一个Master Pod，用来做任务管理器

b. 使用Deployment创建一到N个Work Pod，用来做作业执行者

c. 使用Deployment创建一个N个Redis Pod，用来做作业流程的存储器

## 3. 流程

A. 准备工作

  1) 启动消息队列
  2) 启动Redis
  3) 启动任务管理者，任务管理者将自己的信息注册到Redis中
  4) 启动任务工作者，任务工作者将自己的信息注册到Redis中
  5) 任务管理者Manager订阅（监听）任务结果消息队列，任务工作者Worker订阅（监听）任务队列
     1) 任务管理者对外暴露添加任务接口
     2) 任务管理者对外暴露添加任务执行器的接口，以及添加任务结果分析器的接口
  6) 上述工作完成后，等待用户添加任务

B. 执行工作
  1) 用户调用添加任务执行器接口，返回添加结果
  2) 用户调用添加任务结果分析器接口，返回添加结果
  3) 任务管理器将任务执行接口和任务结果分析器接口信息，放入到Redis中
  4) Worker从Redis中取出任务执行器信息，以及执行结果分析器信息，初始话任务执行，任务分析准备工作。
  5) 用户添加任务
  6) 任务管理器将任务添加到消息队列中，同时将任务添加到Redis中
  7) Worker从队列中取出任务，并根据任务信息，取出任务执行器，进行任务执行。同时更新任务在Redis中的状态
  8) Worker在任务完成后，将结果放入到消息队列中，同时更新任务在Redis中的状态。
  9) 任务管理器将结果从消息队列中取出，使用任务结果分析器，分析结果。
     1)  如果结果中，存在子任务，则调用任务接口，添加任务。
     2)  如果结果中，没有子任务，则将任务完成信息，写入Mysql中。
  10) 如果消息队任务列中没有任务，同时，所有的任务被分析，以及所有的Worker也处于空闲状态，则表示任务最终完成。
   
C. 销毁工作
  1) 删除所有的订阅，删除任务相关的消息队列
  2) 检查Redis的任务相关信息是否为空，不为空，则报错。
  3) 任务执行器停止工作
  4) 任务管理器停止工作

D. 错误以及异常处理
  1) 如果任务执行器接口，任务结果分析接口添加失败怎么办？
     1) 如果添加没有成功，则重新添加。
     2) 如果添加成功，但是没有收到返回消息，重复添加，怎么办。
        1) 解决方案添加必须幂等性。也就是每一个接口必须有一个唯一的标识。
  2) 如果添加任务失败怎么办？
     1) 如果添加没有成功，则重新添加。
     2) 如果添加成功，但是没有收到返回消息，再次添加，怎么办？
        1) 必须幂等。每个任务必须有一个唯一标识。
  3) 如果任务在指定时间内没有执行完成，怎么办？
     1) 保证每个任务只有一个在运行。
     2) 如果执行超时，则任务执行器停止运行任务。将任务重新放入到任务队列中。



  4) 如果Redis重启，怎么办？
     1) 如果Redis
  5) 如果消息队列重启，怎么办？
     1) 消息队列需要支持持久化，重启后，消息队列需要将所有的消息读入。
     2) 消息队列中的任何与操作相关的业务，需要支持幂等性
  6) 如果任务管理器重启，怎么办？
     1) 如果刚开始就重启，则直接重启即可
     2) 如果在注册任务执行器或者任务结果分析器的过程中重启，则直接重启。注册过程要么失败，要么重启后，注册成功
     3) 如果注册之后失败，直接重启即可。
  7) 如果任务执行器重启，怎么办？
  8) 



## 2. 角色

### 2.1 消息队列
1. 需求：
   1. 存储每一个任务
   2. 支持数据持久化
   3. 消息队列重启后：
      1. 能重新将磁盘数据读出，
      2. 能重新和所有的订阅者关联上
      3. 更新消息队列的地址信息等，以便生产者能够添加任务，订阅者能够订阅信息
   4. 生产者能够添加消息
   5. 消费者能够订阅消息（监听消息）
2. 消息队列的队列类型
   1. 待执行任务队列(指定待执行队列的长度，不能过长)
   2. 正在执行任务队列(指定任务的执行超时时间)
3. 实现方式
   1. 使用Kubernete创建一个Deployment，用1-n个pod来提供消息队列服务
   2. 消息队列使用nsq组件。
### 2.2 Redis服务
1. 支持的数据：
   1. 所有的任务列表
   2. 所有的任务执行器列表
   3. 所有的任务结果分析器列表
2. 实现方式
   1. 使用kubernete创建一个Deployment，用1-n个pod来提供Redis服务
### 2.2 任务管理者
1. 需求：
   1. 能够添加任务
   2. 能够添加任务执行器和任务结果分析器
   3. 能够查询任务列表
   4. 能够将超时任务，重新添加到任务队列中
2. 实现
   1. 使用k8s创建一个Deployment，用1个pod提供任务管理者服务。
3. 流程
   1. 启动
      1. 获取Redis的服务地址
      2. 获取任务消息队列的地址
      3. 订阅未完成任务队列
   2. 添加任务流程
      1. 根据任务的唯一标识，判断Redis的任务列表中，是否存在任务。
         1. 如果没有，将任务添加到Redis中，同时将任务添加到任务队列中
         2. 否则，则返回
      2. 如果1发生找不到消息队列错误，则重新获取消息队列服务地址
   3. 添加任务执行器
      1. 根据任务执行器的类型，判断Redis中是否添加过此类任务执行器
         1. 如果没有，则将任务执行器添加到Redis中
         2. 否则，是否替换，如果替换，则添加到Redis中，否则，返回
      2. 如果1发生找不到Redis服务错误，则重新获取Redis服务地址
   4. 添加任务结果处理器
      1. 根据任务结果处理器的类型，判断Redis中是否添加过此类任务结果处理器
         1. 如果没有，则将任务结果处理器添加到Redis中
         2. 否则，是否替换，如果替换，则添加到Redis中，否则，返回
      2. 如果1发生找不到Redis服务错误，则重新获取Redis服务地址
   5. 未完成任务处理
      1. 如果有未完成任务，则启动一个线程，轮循未完成任务队列。
      2. 将未完成任务重新添加到任务队列中
      3. 如果消息队列无法找到，则重新获取消息队列服务地址。
   6. 查询任务
      1. 从中查询所有添加的任务
      2. 从Redis中查询所有任务的状态

### 2.2 作业执行者
1)  执行作业


## 3. 实体
1. 任务
   1. 任务唯一id
   2. 任务类型
2. 任务执行实体
   1. 任务执行id
   2. 任务id
   3. 任务执行开始时间
   4. 任务运行状态(未开始，正在执行中，待重试，完成)
   5. 任务执行器id列表 (可能任务被多个执行器执行过)
   6. 任务执行次数
   7. 任务超时时间
3. 任务结果实体
   1. 任务状态(成功，失败，待下次重试)
   2. 任务id
   3. 任务完成
4. 任务执行器实体
   1. 执行器执行任务类型
   2. 执行器唯一id
   3. 执行器执行方式(exe,url地址等)
   4. 执行器方法文档
5. Redis中运行时数据
   1. 
## 3. 如何与K8s集成

